let counter = 0;
// document.querySelector(".left").disabled = true;
// function goleft() {
//   let boxes = document.querySelectorAll(".section");
//   if (counter) {
//     counter--;
//     document.querySelector(".right").disabled = false;
//     let numbr = 100 * counter;
//     for (const box of boxes) {
//       box.style.transform = `translateX(` + numbr + `vw)`;
//     }
//   } else {
//   }
//   console.log(counter);
// }
// function goright() {
//   let boxes = document.querySelectorAll(".section");
//   if (counter < boxes.length - 1) {
//     document.querySelector(".left").disabled = false;
//     counter++;
//     let numbr = -100 * counter;
//     for (const box of boxes) {
//       box.style.transform = `translateX(` + numbr + `vw)`;
//     }
//   } else {
//     document.querySelector(".right").disabled = true;
//   }
//   console.log(counter);
// }

function move(direction) {
  let boxes = document.querySelectorAll(".section");
  let numbr;
  if (direction === "right" && counter < 2) {
    counter++;
    console.log(counter);
    numbr = -100 * counter;
    for (const box of boxes) {
      box.style.transform = `translateX(` + numbr + `vw)`;
    }
  }
  if (direction === "left" && counter > 0) {
    numbr = 100 - 100 * counter;
    counter--;
    for (const box of boxes) {
      box.style.transform = `translateX(` + numbr + `vw)`;
    }
  }
}

// let counter = 0;

// function goleft() {
//   console.log(counter);
//   if (counter > 0) {
//     counter++;
//     let num = counter * -100;
//     let boxes = document.querySelectorAll(".section");
//     for (const box of boxes) {
//       box.style.transform = `translateX(` + num + `vw)`;
//     }
//   }
// }
// function goright() {
//   console.log(counter);
//   if (counter < 2 && counter >= 0) {
//     counter++;
//     let num = counterRight * -100;
//     let boxes = document.querySelectorAll(".section");
//     for (const box of boxes) {
//       box.style.transform = `translateX(` + num + `vw)`;
//     }
//   } else {
//     let boxes = document.querySelectorAll(".section");
//     for (const box of boxes) {
//       box.style = `disabled`;
//     }
//   }
// }

let open = false;
function showall(order) {
  open = !open;
  if (open === true) {
    document.querySelector(`.element` + order).classList.add("show");
  } else {
    document.querySelector(`.element` + order).classList.remove("show");
  }
}

let info = [
  {
    id: 1,
    heading: "Переменные",
    text: [
      {
        subheading: "Переменная",
        img: "square.svg",
        text: "Переменная – это «именованное хранилище» для данных. Мы можем использовать переменные для хранения товаров, посетителей и других данных. Для создания переменной в JavaScript используйте ключевое слово let. Для лучшей читаемости объявляйте каждую переменную на новой строке.",
      },
      {
        subheading: "Имена переменных",
        text: "В JavaScript есть два ограничения, касающиеся имён переменных: Имя переменной должно содержать только буквы, цифры или символы $ и _. Первый символ не должен быть цифрой. Если имя содержит несколько слов, обычно используется верблюжья нотация, то есть, слова следуют одно за другим, где каждое следующее слово начинается с заглавной буквы: myVeryLongName. Самое интересное – знак доллара '$' и подчёркивание '_' также можно использовать в названиях. Это обычные символы, как и буквы, без какого-либо особого значения.",
      },
      {
        subheading: "Константы",
        text: "Чтобы объявить константную, то есть, неизменяемую переменную, используйте const вместо let. Если программист уверен, что переменная никогда не будет меняться, он может гарантировать это и наглядно донести до каждого, объявив её через const. Широко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения скрипта. Названия таких констант пишутся с использованием заглавных букв и подчёркивания. Название «константа» просто означает, что значение переменной никогда не меняется. Но есть константы, которые известны до выполнения (например, шестнадцатеричное значение для красного цвета), а есть константы, которые вычисляются во время выполнения сценария, но не изменяются после их первоначального назначения.",
      },
      {
        subheading: "Именование переменных",
        text: "В разговоре о переменных необходимо упомянуть, что есть ещё одна чрезвычайно важная вещь. Название переменной должно иметь ясный и понятный смысл, говорить о том, какие данные в ней хранятся. Именование переменных – это один из самых важных и сложных навыков в программировании. Быстрый взгляд на имена переменных может показать, какой код был написан новичком, а какой – опытным разработчиком. В реальном проекте большая часть времени тратится на изменение и расширение существующей кодовой базы, а не на написание чего-то совершенно нового с нуля. Когда мы возвращаемся к коду после какого-то промежутка времени, гораздо легче найти информацию, которая хорошо размечена. Или, другими словами, когда переменные имеют хорошие имена. Пожалуйста, потратьте время на обдумывание правильного имени переменной перед её объявлением. Делайте так, и будете вознаграждены.",
      },
    ],
  },
  {
    id: 2,
    heading: "Типы данных",
    text: [
      {
        subheading: "Число",
        text: "Числовой тип данных (number) представляет как целочисленные значения, так и числа с плавающей точкой. Существует множество операций для чисел, например, умножение *, деление /, сложение +, вычитание - и так далее. Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: Infinity, -Infinity и NaN.",
      },
      {
        subheading: "BigInt",
        text: "В JavaScript тип «number» не может содержать числа больше, чем (253-1) (т. е. 9007199254740991), или меньше, чем -(253-1) для отрицательных чисел. Это техническое ограничение вызвано их внутренним представлением. Для большинства случаев этого достаточно. Но иногда нам нужны действительно гигантские числа, например, в криптографии или при использовании метки времени («timestamp») с микросекундами. Тип BigInt был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины. Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала",
      },
      {
        subheading: "Строка",
        text: "Строка (string) в JavaScript должна быть заключена в кавычки. В JavaScript существует три типа кавычек. Двойные кавычки: \"Привет\".Одинарные кавычки: 'Привет'. Обратные кавычки: `Привет`. Двойные или одинарные кавычки являются «простыми», между ними нет разницы в JavaScript. Обратные же кавычки имеют расширенную функциональность. Они позволяют нам встраивать выражения в строку, заключая их в ${…}. Выражение внутри ${…} вычисляется, и его результат становится частью строки. Мы можем положить туда всё, что угодно: переменную name, или выражение 1 + 2, или что-то более сложное.",
      },
      {
        subheading: "Булевый (логический) тип",
        text: "Булевый тип (boolean) может принимать только два значения: true (истина) и false (ложь). Такой тип, как правило, используется для хранения значений да/нет: true значит «да, правильно», а false значит «нет, не правильно».",
      },
      {
        subheading: "Значение «null»",
        text: "В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».",
      },
      {
        subheading: "Значение «undefined»",
        text: "Специальное значение undefined также стоит особняком. Оно формирует тип из самого себя так же, как и null. Оно означает, что «значение не было присвоено». Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined. Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения, а undefined – для проверок, была ли переменная назначена.",
      },
      {
        subheading: "Объекты и символы",
        text: "Тип object (объект) – особенный.Все остальные типы называются «примитивными», потому что их значениями могут быть только простые значения (будь то строка, или число, или что-то ещё). В объектах же хранят коллекции данных или более сложные структуры. Тип symbol (символ) используется для создания уникальных идентификаторов в объектах. Мы упоминаем здесь о нём для полноты картины, изучим этот тип после объектов.",
      },
    ],
  },
  {
    id: 3,
    heading: "Базовые операторы, математика",
    text: [
      {
        subheading: "Термины: «унарный», «бинарный», «операнд»",
        text: 'Операнд – то, к чему применяется оператор. Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов». \n Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус "-" меняет знак числа на противоположный. \n Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:',
      },
      {
        subheading: "Взятие остатка %",
        text: "Оператор взятия остатка %, несмотря на обозначение, никакого отношения к процентам не имеет. Результат a % b – это остаток от целочисленного деления a на b.",
      },
      {
        subheading: "Возведение в степень **",
        text: "В выражении a ** b оператор возведения в степень умножает a на само себя b раз.",
      },
      {
        subheading: "Сложение строк при помощи бинарного +",
        text: "Давайте рассмотрим специальные возможности операторов JavaScript, которые выходят за рамки школьной арифметики. Обычно при помощи плюса '+' складывают числа. Но если бинарный оператор '+' применить к строкам, то он их объединяет в одну. Обратите внимание, если хотя бы один операнд является строкой, то второй будет также преобразован в строку.",
      },
      {
        subheading: "Приведение к числу, унарный +",
        text: "Плюс + существует в двух формах: бинарной, которую мы использовали выше, и унарной. Унарный, то есть применённый к одному значению, плюс + ничего не делает с числами. Но если операнд не число, унарный плюс преобразует его в число.",
      },
      {
        subheading: "Приоритет операторов",
        text: "В том случае, если в выражении есть несколько операторов – порядок их выполнения определяется приоритетом, или, другими словами, существует определённый порядок выполнения операторов. Из школы мы знаем, что умножение в выражении 1 + 2 * 2 выполнится раньше сложения. Это как раз и есть «приоритет». Говорят, что умножение имеет более высокий приоритет, чем сложение. Скобки важнее, чем приоритет, так что, если мы не удовлетворены порядком по умолчанию, мы можем использовать их, чтобы изменить приоритет. Например, написать (1 + 2) * 2. В JavaScript много операторов. Каждый оператор имеет соответствующий номер приоритета. Тот, у кого это число больше, – выполнится раньше. Если приоритет одинаковый, то порядок выполнения – слева направо.",
      },
      {
        subheading: "Инкремент/декремент",
        text: "Одной из наиболее частых числовых операций является увеличение или уменьшение на единицу. Для этого существуют даже специальные операторы:Инкремент ++ увеличивает переменную на 1, а Декремент - уменьшает переменную на 1",
      },
    ],
  },
  {
    id: 4,
    heading: "Циклы while и for",
    text: [
      {
        subheading: "Цикл «while»",
        text: "Цикл while имеет следующий синтаксис: while (condition) {}. Код из тела цикла выполняется, пока условие condition истинно. Одно выполнение тела цикла по-научному называется итерация. Любое выражение или переменная может быть условием цикла, а не только сравнение: условие while вычисляется и преобразуется в логическое значение. Например, while (i) – более краткий вариант while (i != 0)",
      },
      {
        subheading: "Цикл «do…while»",
        text: "Цикл сначала выполнит тело, а затем проверит условие condition, и пока его значение равно true, он будет выполняться снова и снова. Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла выполнилось хотя бы один раз, даже если условие окажется ложным. На практике чаще используется форма с предусловием: while(…) {…}.",
      },
      {
        subheading: "Цикл «for»",
        text: "Более сложный, но при этом самый распространённый цикл — цикл for. for (let i = 0; i < 3; i++) {}",
      },
      {
        subheading: "Прерывание цикла: «break»",
        text: "Обычно цикл завершается при вычислении условия в false. Но мы можем выйти из цикла в любой момент с помощью специальной директивы break. Вообще, сочетание «бесконечный цикл + break» – отличная штука для тех ситуаций, когда условие, по которому нужно прерваться, находится не в начале или конце цикла, а посередине или даже в нескольких местах его тела.",
      },
      {
        subheading: "Переход к следующей итерации: continue",
        text: "Директива continue – «облегчённая версия» break. При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true). Её используют, если понятно, что на текущем повторе цикла делать больше нечего.",
      },
    ],
  },
  {
    id: 5,
    heading: "Функции",
    text: [
      {
        subheading: "Объявление функции",
        text: "Для создания функций мы можем использовать объявление функции. Вначале идёт ключевое слово function, после него имя функции, затем список параметров в круглых скобках через запятую (в вышеприведённом примере он пустой) и, наконец, код функции, также называемый «телом функции», внутри фигурных скобок.",
      },
      {
        subheading: "Локальные переменные",
        text: "Переменные, объявленные внутри функции, видны только внутри этой функции. Если одноимённая переменная объявляется внутри функции, тогда она перекрывает внешнюю.",
      },
      {
        subheading: "Внешние переменные",
        text: "У функции есть доступ к внешним переменным. Функция обладает полным доступом к внешним переменным и может изменять их значение.",
      },
      {
        subheading: "Глобальные переменные",
        text: "Глобальные переменные видимы для любой функции (если только их не перекрывают одноимённые локальные переменные). Желательно сводить использование глобальных переменных к минимуму. В современном коде обычно мало или совсем нет глобальных переменных. Хотя они иногда полезны для хранения важнейших «общепроектовых» данных.",
      },
      {
        subheading: "Параметры",
        text: "Мы можем передать внутрь функции любую информацию, используя параметры (также называемые аргументами функции). Если параметр не указан, то его значением становится undefined.",
      },
      {
        subheading: "Возврат значения",
        text: "Директива return может находиться в любом месте тела функции. Как только выполнение доходит до этого места, функция останавливается, и значение возвращается в вызвавший её код (присваивается переменной result выше).",
      },
    ],
  },
  {
    id: 6,
    heading: "Функции-стрелки",
    text: [
      {
        subheading: "Основы",
        text: "Существует ещё более простой и краткий синтаксис для создания функций, который часто лучше, чем синтаксис Function Expression.",
      },
      {
        subheading: "Многострочные стрелочные функции",
        text: "Порой нам нужно что-то посложнее, например, выполнить несколько инструкций. Это также возможно, нужно лишь заключить инструкции в фигурные скобки. И использовать return внутри них, как в обычной функции.",
      },
    ],
  },
  {
    id: 7,
    heading: 'Обработка ошибок, "try..catch"',
    text: [
      {
        subheading: "Синтаксис «try…catch»",
        text: "Конструкция try..catch состоит из двух основных блоков: try, и затем catch",
      },
      {
        subheading: "Объект ошибки",
        text: "Когда возникает ошибка, JavaScript генерирует объект, содержащий её детали. Затем этот объект передаётся как аргумент в блок catch.",
      },
      {
        subheading: "Генерация собственных ошибок",
        text: "Что если json синтаксически корректен, но не содержит необходимого свойства name? Здесь JSON.parse выполнится без ошибок, но на самом деле отсутствие свойства name для нас ошибка. Для того, чтобы унифицировать обработку ошибок, мы воспользуемся оператором throw. Оператор throw генерирует ошибку. throw <объект ошибки> Технически в качестве объекта ошибки можно передать что угодно. Это может быть даже примитив, число или строка, но всё же лучше, чтобы это был объект, желательно со свойствами name и message (для совместимости со встроенными ошибками).",
      },
      {
        subheading: "try…catch…finally",
        text: "Конструкция try..catch может содержать ещё одну секцию: finally. Секцию finally часто используют, когда мы начали что-то делать и хотим завершить это вне зависимости от того, будет ошибка или нет. Секция finally отлично подходит для завершения измерений несмотря ни на что.",
      },
    ],
  },
  {
    id: 8,
    heading: "Условное ветвление: if, '?'",
    text: [
      {
        subheading: "Основы",
        text: "Иногда нам нужно выполнить различные действия в зависимости от условий. Для этого мы можем использовать инструкцию if и условный оператор ?, который также называют оператором «вопросительный знак». Инструкция if(...) вычисляет условие в скобках и, если результат true, то выполняет блок кода.",
      },
      {
        subheading: "Преобразование к логическому типу",
        text: "Инструкция if (…) вычисляет выражение в скобках и преобразует результат к логическому типу.",
      },
      {
        subheading: "Блок «else»",
        text: "Инструкция if может содержать необязательный блок «else» («иначе»). Он выполняется, когда условие ложно.",
      },
      {
        subheading: "Несколько условий: «else if»",
        text: "Иногда, нужно проверить несколько вариантов условия. Для этого используется блок else if.",
      },
      {
        subheading: "Условный оператор „?“",
        text: "Так называемый «условный» оператор «вопросительный знак» позволяет нам сделать это более коротким и простым способом. Оператор представлен знаком вопроса ?. Его также называют «тернарный», так как этот оператор, единственный в своём роде, имеет три аргумента. let result = условие ? значение1 : значение2;",
      },
      {
        subheading: "Несколько операторов „?“",
        text: "Последовательность операторов вопросительного знака ? позволяет вернуть значение, которое зависит от более чем одного условия.",
      },
    ],
  },
  {
    id: 9,
    heading: "Оператор объединения с null ??",
    text: [
      {
        subheading: "??",
        text: "В этой статье мы будем говорить, что значение выражения «определено», если оно отличается от null или undefined. Оператор объединения с null представляет собой два вопросительных знака ??. То есть оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй. Оператор объединения с null не является чем-то принципиально новым. Это всего лишь удобный синтаксис, как из двух значений получить одно «определённое». Как правило, оператор ?? нужен для того, чтобы задать значение по умолчанию для потенциально неопределённой переменной.",
      },
      {
        subheading: "Сравнение с ||",
        text: 'Оператор ИЛИ || можно использовать для того же, что и ??, как это было показано в предыдущей главе. Оператор ИЛИ || существует с самого появления JavaScript, поэтому ранее для решения похожих задач разработчики использовали именно его. Проще говоря, оператор || не различает false, 0, пустую строку "" и null/undefined. Для него они все одинаковые, т.е. являются ложными значениями. Если первым аргументом для оператора || будет любое из перечисленных значений, то в качестве результата мы получим второй аргумент. Однако на практике часто требуется использовать значение по умолчанию только тогда, когда переменная является null/undefined. Ведь именно тогда значение действительно неизвестно/не определено.',
      },
    ],
  },
  {
    id: 10,
    heading: "Взаимодействие: alert, prompt, confirm",
    text: [
      {
        subheading: "alert",
        text: "С этой функцией мы уже знакомы. Она показывает сообщение и ждёт, пока пользователь нажмёт кнопку «ОК». Это небольшое окно с сообщением называется модальным окном. Понятие модальное означает, что пользователь не может взаимодействовать с интерфейсом остальной части страницы, нажимать на другие кнопки и т.д. до тех пор, пока взаимодействует с окном. В данном случае – пока не будет нажата кнопка «OK».",
      },
      {
        subheading: "prompt",
        text: "Вызов prompt возвращает текст, указанный в поле для ввода, или null, если ввод отменён пользователем.",
      },
      {
        subheading: "confirm",
        text: "Функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена. Результат – true, если нажата кнопка OK. В других случаях – false.",
      },
    ],
  },
  {
    id: 11,
    heading: "Копирование объектов и ссылки",
    text: [
      {
        subheading: "Сравнение по ссылке",
        text: "Операторы равенства == и строгого равенства === для объектов работают одинаково. Два объекта равны только в том случае, если это один и тот же объект. Для сравнений типа obj1 > obj2 или для сравнения с примитивом obj == 5 объекты преобразуются в примитивы. Мы скоро изучим, как работают такие преобразования объектов, но, по правде говоря, сравнения такого рода необходимы очень редко и обычно являются результатом ошибки программиста.",
      },
      {
        subheading: "Клонирование и объединение объектов, Object.assign",
        text: "Таким образом, при копировании переменной с объектом создаётся ещё одна ссылка на тот же самый объект. Но что, если нам всё же нужно дублировать объект? Создать независимую копию, клон? Это выполнимо, но немного сложно, так как в JavaScript нет встроенного метода для этого. На самом деле, такая нужда возникает редко. В большинстве случаев нам достаточно копирования по ссылке.",
      },
      {
        subheading: "Вложенное клонирование",
        text: "До сих пор мы предполагали, что все свойства объекта user хранят примитивные значения. Но свойства могут быть ссылками на другие объекты. Что с ними делать? Теперь при клонировании недостаточно просто скопировать clone.sizes = user.sizes, поскольку user.sizes – это объект, он будет скопирован по ссылке. А значит объекты clone и user в своих свойствах sizes будут ссылаться на один и тот же объект.",
      },
    ],
  },
];

let potato = info.map((inf) => inf.heading);
function newData(n) {
  document.querySelector(".textbook_information_container").innerHTML = info[
    n - 1
  ].text
    .map(
      (inf) => `<h1></h1><h5>` + inf.subheading + `</h5><p>` + inf.text + `</p>`
    )
    .join("");
  document.querySelector(".textbook_topic_heading").innerHTML =
    info[n - 1].heading;
}

// let scrollPos = 0;
// const nav = document.querySelector("#goUp");

// function checkPosition() {
//   let windowY = window.scrollY;
//   if (windowY < scrollPos) {
//     // Scrolling UP
//     nav.classList.add("shown");
//     nav.classList.remove("hidden");
//   } else {
//     // Scrolling DOWN
//     nav.classList.add("hidden");
//     nav.classList.remove("shown");
//   }
//   scrollPos = windowY;
//   console.log(windowY);
// }

// window.addEventListener("scroll", checkPosition);

goUp = document.getElementById("goUp");
goUp.addEventListener("click", () => {
  document.body.scrollTop = 0;
  document.documentElement.scrollTop = 0;
});

function menuOpen() {
  document.querySelector(".navbar_container").classList.add("opened");
}
function menuClose() {
  document.querySelector(".navbar_container").classList.remove("opened");
}
function themeShow() {
  document
    .getElementsByClassName(".textbook_information_section")
    .classList.add("hidden");
}
